import { join } from "path";
import { mkdir, writeFile, rm } from "fs/promises";
import { existsSync } from "fs";

export interface CompileResult {
  programId: string;
  programPath: string;
  idlPath?: string;
  programKeypairPath?: string;
  success: boolean;
  error?: string;
}

export class ProgramCompiler {
  private readonly workDir: string;

  constructor(workDir: string = "/tmp/solana-programs") {
    this.workDir = workDir;
  }

  async compile(
    templateId: string,
    code: string,
    workspaceDir?: string
  ): Promise<CompileResult> {
    const resolvedWorkspace = workspaceDir ?? join(this.workDir, templateId);
    const programName = templateId.replace(/-/g, "_");
    
    try {
      if (!existsSync(resolvedWorkspace)) {
        await mkdir(resolvedWorkspace, { recursive: true });
      }

      const programId = this.extractProgramId(code);
      if (!programId) {
        throw new Error("Failed to extract program ID from declare_id!");
      }

      await this.writeAnchorWorkspace(resolvedWorkspace, programName, programId, code);
      await this.runAnchorBuild(resolvedWorkspace);

      return {
        programId,
        programPath: join(resolvedWorkspace, "target/deploy", `${programName}.so`),
        idlPath: join(resolvedWorkspace, "target/idl", `${programName}.json`),
        programKeypairPath: join(
          resolvedWorkspace,
          "target/deploy",
          `${programName}-keypair.json`
        ),
        success: true,
      };
    } catch (error) {
      return {
        programId: "",
        programPath: "",
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  async cleanup(templateId: string): Promise<void> {
    const programDir = join(this.workDir, templateId);
    try {
      if (existsSync(programDir)) {
        await rm(programDir, { recursive: true, force: true });
      }
    } catch (error) {
      console.error(`Failed to cleanup ${templateId}:`, error);
    }
  }

  private extractProgramId(code: string): string | null {
    const match = code.match(/declare_id!\(\"([A-Za-z0-9]+)\"\)/);
    return match?.[1] ?? null;
  }

  private async writeAnchorWorkspace(
    workspaceDir: string,
    programName: string,
    programId: string,
    code: string
  ): Promise<void> {
    const programsDir = join(workspaceDir, "programs", programName, "src");
    await mkdir(programsDir, { recursive: true });

    const anchorToml = `
[features]
seeds = false
skip-lint = false

[programs.localnet]
${programName} = "${programId}"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "${join(workspaceDir, "keys", "payer.json")}"
`.trim();

    const workspaceCargo = `
[workspace]
members = [
  "programs/${programName}"
]
`.trim();

    const programCargo = `
[package]
name = "${programName}"
version = "0.1.0"
description = "Generated by Solana Playground"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
anchor-lang = "0.30.1"
anchor-spl = "0.30.1"
`.trim();

    await mkdir(join(workspaceDir, "keys"), { recursive: true });
    await writeFile(join(workspaceDir, "Anchor.toml"), anchorToml, "utf-8");
    await writeFile(join(workspaceDir, "Cargo.toml"), workspaceCargo, "utf-8");
    await writeFile(join(workspaceDir, "programs", programName, "Cargo.toml"), programCargo, "utf-8");
    await writeFile(join(programsDir, "lib.rs"), code, "utf-8");
  }

  private async runAnchorBuild(workspaceDir: string): Promise<void> {
    const { execFile } = await import("child_process");
    const { promisify } = await import("util");
    const execFileAsync = promisify(execFile);
    await execFileAsync("anchor", ["build"], { cwd: workspaceDir, env: process.env });
  }
}
